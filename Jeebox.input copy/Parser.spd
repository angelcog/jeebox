
/*
	Jeebox internals. By Theodore H. Smith...
*/

/*

~/ adadadas, asasdas /~

*/

// a struct might be faster? than a module... rather than read that global everytime...
// LATER when I'm bored and got noting better to do XDD
prototype ParseHandler (|int|Start, |Message|)


extend Parser {
///////////////////////////////////////////////////////////////////////////// 

	function Init {		
		|| lines	=   "\r \n" // (no one uses \r\n anymore)
		|| numb	 =   "0123456789".bytesplit
		|| op_comp  =   "= == === < > <= <== >= >== != !== <=> ~>= ~<= ~> ~< ~= ~!= ~<=> :="
		|| op_math  =   "* / + - ^ >> << >>> <<< ||| &&& ^^^"
		|| PFix		=	"++ -- $ & ! ?"
		
		|| H = .Handler( kThingWord, fThingWord& ).Link( kTemporalWord, fTemporalStatement& ).Link( kOppWord, fOppWord& )

		.Tokens( Jeebox.CSWordStart.Bytes, H )
		
		.Token( "(" )  = .Handler( kFuncAfterNoSpace, fFuncCall& ).link( kThingSyx, fBracket& ).Link( kOppBra, fOppBracket& )
		.Token( "[" )  = .Handler( kFuncAfterNoSpace, fAccess& ).Link( kThingSyx, fArray& )
		.Token( "«" )  = .Handler( kThingSyx, fMsgList& )
		.Token( "." )  = .Handler( kFuncAfterNoSpace, fDot& ).Link( kThingSyx, fSDot& )
		.Token( "|" )  = .Handler( kFuncAfterBar, fBarTypeCast& ).link( kTemporalSyx, fDecl& )

		.Token( "@" )  = .Handler( kThingSyx, fAtName& ).Link( kFuncAfterNormal, fAtNamedExp& )

		.Token( "~" )  = .Handler( kFuncAfterNormal, fAdjectiveThing& ).Link( kAdjectiveOp, fAdjectiveOp& )
		// -~ would be a good "Backwards adj"... assuming we even need it.
		// muise-~je



// POSTFIX-PREFIX
		.Tokenz( "- *",		 kThingSyx,				fBeforeRelMinus&	)
		.Tokenz( PFix, 			kThingSyx,				fBeforeRel&			)
		.Tokenz( PFix,	 		kFuncAfterNormal,		fAfterRel&			)

// Everything else
		.Tokenz( ":",			kColon										)
		.Tokenz( "::",			kThingSyx,				fTemporalAsThing&   )

		.Tokenz( "{",			kThingSyx,			  fStatementOpen&  	)
		.Tokenz( "#",			kTmpOpp,			  	fTemporalRel&		)
		.Tokenz( "--> <-- <-->", kTmpOpp,				fTemporalRelSyx& 	)
		.Tokenz( "%",			kThingSyx, 				fOpAsThing&	  	)
		.Tokenz( `–`,		   kThingSyx,				fAnaphoricReference&)
		.Tokenz( "∆",			kThingSyx,	  		fQuestion&			)
		.Tokens( numb,			kThingSyx,			  fNumber&			)
		.Tokenz( "#!",			kTemporalSyx,		   fShebang&			)
		.Tokenz( "//",			kEndOfLine + kWords_Line, fCommentLine&		)
		.Tokenz( "/*",			kEndOfLine + kWords_Line, fComment&   		)
		.Tokenz( Lines,   		kEndOfLine + kWords_Line					)
		.Tokenz( ",",   		kEndOfLine									)
		.Tokenz( op_comp, 		kOppSyx,				fOppSyxNeq&  		)
		.Tokenz( op_math, 		kOppSyx,	  			fOppSyx&			)
		.Tokenz( "¬",			kOppYoda,	  			fOppYoda&			)
		.Tokenz( "...", 	  	kThingSyx,			  fThingSyx&		  )
		.Tokenz( `"`,   		kThingSyx,			  fString2&			)
		.Tokenz( "'",	 		kThingSyx,			  fChr&			   )
		.Tokenz( "`",		   kThingSyx, 				fBackTick&		  )
		.Tokenz( "<(`",		 kThingSyx, 				fSuperStr&		  )
		.Tokenz( "~~~",			kThingSyx,			  fBeforeRel&		 )
		.Tokenz( "/#", 			kSyntacticComment,		fSyntacticComment&  )
		.Tokenz( "#(", 			kThingSyx,			  fBinary&			)



// Ender //
		.Tokenz( "] ) } #/ /~ »", kEndContainer							)

		|| IllegalHandler = .Handler( -1, fError& ) // catch all?
		for ( i : 256 ) {
			.TokenNil( string.byte(i) ) = IllegalHandler&
		}
	}

///////////////////////////////////////////////////////////////////////////// 
///////////////////////////////////////////////////////////////////////////// 
	
	function ExpectEndChar (|string| s, |bool| Expect = true, |bool|) {
		.CleanSpaces
		if (.Eats(s)) {
			return true
		}

		if (Expect) { // and !(.EatsByte(s)) {
//			.NeedsErrorImprove
			.ErrorAdd( "Missing '$s'", parser.nextstart, true )
		}
	}
	
	
	function BarThings (|int| Start, |syntax| Syx, |Message|) {
		StopBars = kFuncAfterBar ||| kTemporalSyx

		|| item = .ProcessThing
		if (!item) {
			item = parser.new(nil, @Emb, start)
		} elseif .Allow(kColon) {
			Item = .ParseItem(Item, 0)
		}

		StopBars = 0

		require .ExpectEndChar("|")

		|| Result = parser.new(nil, Syx, Parser.NextStart - 1)
		result ~ item
		return result
	}


	function ChainTemporalRels (|Message| FirstThing, |Message| opp, |Message|) {
		|| Result = parser.new(nil, @TRel, opp.position)
		Result ~ FirstThing
		Result ~ opp
		
		if ( !.WillEnd ) {
			|| Last = .ProcessThing
			if (Last) {
				return Result.FixTRels( Last )
			}
		}

		return Result
	}


	function Deny (|Int| Bits, |bool|) {
		|| n = .Nextstart
		
		if ( ! .Allow( Bits ) ) {
			Return true
		}
		
		.Nextstart = n
		.Expect( ~~~Bits )
	}


	function DotSub (|syntax| fn, |int| Start, |Message|) { opt norefcounts
		// 					   x.fn(a)

		if !jeebox.CSWordStart.has(.data[++start]) {
			.ErrorLetter( start )
			return nil
		}

		|| After = .WordAfter(start) #require
		|| Result = parser.new(nil, fn, start, After) 
		
		if ( .Eats("(") ) {
			.Params( result, After )
		} else {
			parser.new(result, @emb, After) // for Javascript where "a.b" != "a.b()"
		}
		
		return result
	}


///////////////////////////////////////////////////////////////////////////// 

	function fAccess (ParseHandler) {
		// x[a,b]
		|| result = parser.new(nil, @Acc, start)
		|| prms = parser.new(result, @Arr, start)
		parser.ParseLoop(prms, "]")
		return result
	}
	
	
	function fAdjectiveThing (ParseHandler) {
		//						 x~y
		|| result = parser.New(nil, @Adj, start)
		result ~ parser.ProcessThing( 0, Parser.kExpect )
		return result
	}
	
	
	function fAfterRel (ParseHandler) {
		return parser.New( nil, @ARel, Start, parser.NextStart )
	}
	

	function fArray (ParseHandler) {
		// x = [a, b, c:d, e:]
		|| Result = parser.new( nil, @Arr, Start )
		parser.ParseLoop( Result, "]" )
		return Result
	}


	function fMsgList (ParseHandler) {
		/*
			x = «dot "oof"
				«thg name »
			»
			x = «dot "oof", «thg name »»
		*/ 
		
		|| Result = parser.new( nil, @msg, Start )
		|| Ops = kOppSyx ||| kOppTemporal ||| kOppYoda

		while (!.willend) {
			|| item = .ProcessThing(Ops, false)
			.ConsumeLines(result, item)
		}

		parser.ExpectEndChar("»")
		return Result
	}


	function fAtName (ParseHandler) {
		return parser.newWord( nil,  @name,  Start,  Parser.NextStart )
	}

	function fAtNamedExp (ParseHandler) {
		|| result = parser.new(nil, @name, start)
		result ~ parser.ProcessThing(0, Parser.kExpect)
		return result
	}


	function fStrSub (|int| Start, |string| Ender, |syntax| syx, |Message|) {
		|| After = Parser.data.find( Ender, Parser.Nextstart )
		if (!After.found) {
			return Parser.ErrorAdd( "String did not close." )
		}
		
		|| FindLen = Ender.length
		Parser.NextStart = After + FindLen
		return parser.newSkip( nil, syx, start, start + FindLen, after )
	}

	function fBackTick (ParseHandler) {
		return fStrSub(Start, "`", @back)
	}
	
	function fSuperStr (ParseHandler) {
		return fStrSub(Start, "`)>", @sstr)
	}


	function fBarTypeCast (ParseHandler) {
		//					   a|x|
		return parser.BarThings( Start, @Type ) // Types
	}


	function BeforeRelSub (|int| Start, |bool| Mode, |Message|) {
		|| Result = parser.new( nil, @Brel, start, parser.NextStart )
		|| Thg = parser.ProcessThing( 0, Mode ) #require
		result ~ Thg
		return result
	}

	
	function fBeforeRelMinus (ParseHandler) {
		// help against:
		//	 Count -= 1
		// Count is a tmp... then we have "-" which is a brel...
		// then it expects a thing after... but it finds "="
		// so it rejects it!
		
		// we ALSO want to handle stuff like -10 as a number
		// just... makes things easier to use!

		|| c = parser.data[start+1]
		if (c.isnum and parser.data[start]=='-') {
			return Numbersub(start+1, start)
		}

		return Parser.BeforeRelSub(Start, Parser.kAllow)
	}


	function fBeforeRel (ParseHandler) {
		return Parser.BeforeRelSub(Start, Parser.kExpect)
	}


	function fBracket (ParseHandler) { opt norefcounts
			  // (,,a:b,,c:d,e,)

		|| Result = parser.new(nil, @list, start)
		if (parser.ParseLoop( result, ")" )) {
			if (result.first != @item) {
				result.Func = @Bra
			}
		}
		
		return result
	}


	function Params (|message| Parent, |int| N) {
			  // (,,a:b,,c:d,e,)
		|| Result = parser.new(parent, @list, N)
		.ParseLoop(result, ")")
	}


	function fChr (ParseHandler) {
		|| After = parser.data.jbfind( '\'', parser.Nextstart, int.max )
		if (!After.found) {
			Return parser.ErrorAdd( "Char didn't close!" )
		}
		
		parser.NextStart = After + 1
		|| name = parser.Data[ start + 1, After ].unescape
		return parser.new( nil, @char, start, name ) 
	}


	function fCommentLine (ParseHandler) {
		parser.NextStart = parser.data.find( Jeebox.CSLine, parser.Nextstart )
		return parser.Avoid
	}


	function fComment (ParseHandler) {
		|| Count = 1
		|| i = parser.NextStart
		|| d = parser.data
		while {
			i = d.find( '/', i + 1 )
			if (!i.found) {
				return parser.ErrorAdd( "Comment did not close.", start )
			} elseif (d[ i - 1 ] == '*') {
				count--
			} elseif (d[ i + 1 ] == '*') {
				count++
				i = i + 2
			}
		} (count)
		
		parser.NextStart = i + 1
		return parser.Avoid
	}

	function fDecl (ParseHandler) {
		//  |x| a = b
//		debugat(9)
		
		|| Result = parser.BarThings( Start, @Decl ) #require

		while (!parser.WillEnd) {
			|| Curr = parser.ProcessThing(kOppsyx|||kopptemporal)
			if (!Curr) {
				parser.Expect( kEnd )
				exit
			}
			result ~ curr
		}

		return Result
	}


	function fDot (ParseHandler) {
		return parser.DotSub( @dot, start )
	}


	function fFuncCall (ParseHandler) {
		|| Result = parser.new(nil, @Func, start)
		parser.Params( result, start )
		return Result
	}


	function NumEnd ( |string| D, |int| Start, |int| ) {
		// "2..."			NO
		// "1.2.3.4"		NO
		// "2.12"			OK
		// 3.BitCount		"3", not "3."

		|| Dot = D.OutCharSet( Jeebox.CSNum, Start )
		if (!dot.found) {
			return d.length
		}
		if ( D[Dot] != '.' ) {
			return Dot
		}

		|| CNext = D[ Dot + 1 ]
		if (!CNext.IsNumeric) {
			return Dot
		}
		|| Result = D.OutCharSet( Jeebox.CSNum, Dot + 1 )
		if (!Result.found) {
			result = D.length
		}
		return result
	}
	

	function string.IsHexLike (|int|N=0, |int|) {
		if (self[N + 0x0] == '0') {
			|| X = self[N + 1]
			// just test that it's not a number?
			// and also not "_" or "."
			// 0b000, 0x00, 0z000
			if (X.isletter) {return 2}
		}
	}


	function fNumber (ParseHandler) {
		return Numbersub(start, start)
	}


	function NumberSub (|int| Start, |int| RealStart, |Message|) {
		opt NoRefCounts
		
		|| After = parser.NumEnd( .Data, Start )
		parser.NextStart = After
		|| StartAt = .data.IsHexLike( Start )

		|| UnitPos2 = .Data.OutCharSet( Jeebox.CSLettersOnly, After, Start + StartAt )
		if (!UnitPos2.Found) {
			UnitPos2 = After - 1
		} 
		UnitPos2++
		|| Num = parser.new( nil, @Num, RealStart, UnitPos2 )
		if (After <= UnitPos2) {
			return Num
		}
		
		|| unit = parser.new( nil, @Unit, unitpos2, After )
		unit ~ num
		return unit
	}


	function fOpAsThing (ParseHandler) {
		|| Result = parser.new( nil, @Oat, start)
		result ~ parser.Process( kOpp )
		result ~ parser.ProcessThing
		return Result
	}
	

	function fAdjectiveOp (ParseHandler) {
		|| result = parser.new( nil, @Adj, start )
		result ~ parser.Process( kOppChain, Parser.kExpect )
		return result
	}


	function OppChain (|Message| opp, |Message|) {
		|| result = parser.Process( kAdjectiveOp )
		if (!result) {
			return opp
		}

		result.First = opp
		return result
	}
	
	
	function fOppWord (ParseHandler) {
		|| After = parser.WordAfter( start )
		|| C = parser.data[after]
		require (C != '.') // really should check for all bytes that can't come directly after
						// if test() a.b, if test() a++
		|| opp = parser.new( nil, @Opp, start, after )
		return parser.OppChain( opp )
	}
	
	
	function fOppBracket (ParseHandler) {
		|| result = parser.new( nil, @Bra, start )
		|| opp1 = parser.Process( kOppChain )
		|| opp2 = parser.Process( kOpp )
		if (opp2) {
			|| rel = parser.new( result, @rel, parser.nextstart - 1 )
			rel ~ opp1
			rel ~ opp2
			rel ~ parser.Process( kOppChain )
		} else {
			result ~ opp1
		}
		parser.ExpectEndChar( ")" )

		return parser.OppChain( result )
	}
	
	

	function fOppSyx (ParseHandler) {
		// needed to change parse-mode internally
		return parser.new( nil, @SOpp, start, parser.nextstart )
	}


	function fOppSyxNeq (ParseHandler) {
		|| result = parser.fOppSyx(start)
		|| c = parser.NextByte
		if (c == '=') {
			Return parser.ErrorAdd( "Can’t have '=' after this operator." )
		}
		return result
	}
	
	function fOppYoda (ParseHandler) {
		return parser.new( nil, @yopp, start, parser.nextstart )
	}

	
	function fQuestion (ParseHandler) {
		|| opp = parser.process(kopp, parser.kexpect)
		|| first = parser.processthing(koppsyx, parser.kexpect)
		|| last = parser.processthing(kopp, parser.kallow)
		require first and opp
		|| rel = parser.new( nil, @ask, start )
		rel ~ first
		rel ~ opp
		rel ~ last
		return rel
	}


	function fThingSyx (ParseHandler) {
		return parser.New( nil, @SThg, Start, parser.nextstart )
	}

	
	function fSDot (ParseHandler) {
		// 							.fn(a)
		if (Start > 0) {
			require !Jeebox.CSWordMiddle.has(parser.data[ Start - 1 ] )
		}
	  	Return parser.DotSub( @SDot, start )
	}


	function fShebang (ParseHandler) {
		|| S = parser.Nextstart
		|| S2 = parser.data.find( Jeebox.CSLine, S )
		parser.NextStart = S2

		return parser.NewSkip( nil, @Sheb, start, S, S2 )
	}


	function fStatementOpen (ParseHandler) {
		|| Result = parser.new( nil, @Arg, start )
		parser.ParseLoop( result, "}" )
		return result
	}


	function fString2 (ParseHandler) {
		|| After = parser.data.jbfind( '"', parser.Nextstart, int.max )
		if (!After.found) { return parser.ErrorAdd( "String didn't close!" ) }
		
		|| StrPos = start + 1
		|| result = parser.new( nil, @Str, start )

		while {
			|| NewStrPos = parser.data.jbfind( '$', StrPos, After)
			if (!NewStrPos.found) {
				NewStrPos = After
			} 
			
			if NewStrPos > StrPos {
				|| Str = parser.new(result, @Emb, StrPos, NewStrPos )
				str.name = str.name.unescape
			}
			if (NewStrPos >= After) {
				exit
			}
			
			NewStrPos++
			|| C0 = parser.data[NewStrPos]  
			if (C0 == '{') {
				NewStrPos++
			}
			parser.NextStart = NewStrPos

			if (C0 == '{') {
				StrPos = parser.EmbeddedCode( "}", result, @List.ParseFlags )
			} else {
				StrPos = parser.data.OutCharSet( jeebox.cswordmiddle, newstrpos + 1, after )
				if !strpos.found { strpos = after }
				parser.new(result, @thg, NewStrPos, StrPos )
			}
			
			if (StrPos > After) {
				return parser.ErrorAdd("Embedded expression didn't close.", NewStrPos)
			}
		}
		
		parser.NextStart = After + 1
		result.UnEmbed
		return result
	}
	

/*
	function fString (ParseHandler) {
		|| After = parser.data.jbfind( '"', parser.Nextstart, int.max )
		if (!After.found) { return parser.ErrorAdd( "String didn't close!" ) }
		
		|| StrPos = start + 1
		|| result = parser.new( nil, @Str, start )
		
		while {
			|| NewStrPos = parser.data.find( "$\{", StrPos, After )
			if (!NewStrPos.found) {
				NewStrPos = After
			}

			
			if NewStrPos > StrPos {
				|| Str = parser.new(result, @Emb, StrPos, NewStrPos )
				str.name = str.name.unescape
			}
			if (NewStrPos >= After) {
				exit
			}
			
			parser.NextStart = NewStrPos + 2

			|| OldLast = result.Last
			StrPos = parser.EmbeddedCode( "}", result, @List.ParseFlags )
			if (result.Last == OldLast) {
				return parser.ErrorAdd("No expression found.", NewStrPos)
			}
			
			if (StrPos > After) {
				return parser.ErrorAdd("Embedded expression didn't close.", NewStrPos)
			}
		}
		
		parser.NextStart = After + 1
		result.UnEmbed
		return result
	}
*/

	function fSyntacticComment (ParseHandler) {
		|| Result = parser.new( nil, @SCom, start )
		parser.EmbeddedArg( "#/", Result, @List )
		return Result
	}


	function fTemporalAsThing (ParseHandler) {
		return parser.Process( kTemporal, Parser.kExpect )
	}
	
	
	function fTemporalRel (ParseHandler) {
		parser.CleanSpaces
		return parser.newWord( nil, @Cnj, start, parser.NextStart )
	}
	
	
	function fTemporalRelSyx (ParseHandler) {
		return parser.new( nil, @SCnj, start, parser.nextstart )
	}
	
	
	function fTemporalStatement (ParseHandler) {
		|| After = parser.WordAfter( start )
		if (parser.WillEnd) {
			return parser.new( nil, @Tmp, start, After )
		}

		require ( Jeebox.CSAfterTemporal.has( parser.NextByte ) )

		|| result
		
		while {
			|| item = parser.ProcessThing( kOpp &&& ~~~kOppBra )
			if (!item) {exit}
			result := parser.new( nil, @Tmp, start, After )
			result ~ item

			if (parser.WillEnd) { return result }
			
			if (item == @Arg) {
				|| SubTmp = parser.Process( kTemporalWord )
				if SubTmp {
					result ~ subtmp
					return result
				}
			}
		}
	}


	function fAnaphoricReference (ParseHandler) {
		return parser.NewWord( nil, @Ana, Start, parser.nextStart )
	}
	
	function fThingWord (ParseHandler) {
		|| name = parser.WordAfter( start )
		return parser.new( nil, @Thg, start, name )
	}


	function EmbeddedArg (|String|close, |Message| result, |Syntax| Mode, |int|) {
		|| arg = parser.new( Result, @Arg, parser.nextstart )
		return parser.EmbeddedCode( close, arg, Mode.ParseFlags )
	}

	
	function EmbeddedCode (|String| close, |Message| dest, |int| Mode, |int|) {
		// should this... make sure we get at least one?
		
		|| result = .Data.find( close, parser.NextStart )
		if (!result.found) {
			parser.ErrorAdd( "Missing $close" )
			return result
		}
		
		
		parser.ParseLoopMode( dest, Mode )
		
		
		if (.NextStart > result) {
			parser.ErrorAdd( "Nested '$close' not allowed.", result )
			return result
		}
		
		result += close.length
		parser.NextStart = result
		return result
	}


///////////////////////////////////////////////////////////////////////////

	function NoFuncAfter ( |byte| b, |bool| ) {
		return (b == '\t') or (b == ' ') or (b == '\\')
	}

	function GetFuncAfter (|Message| input, |Message|) {
		|| Result = input

		while {
			|| ThisAfter = kFuncAfterAny &&&~~~ StopBars
			if (NoFuncAfter(.NextByte)) {
				ThisAfter = ThisAfter &&&~~~ kFuncAfterNoSpace
			}
			
			|| d = .Process( ThisAfter )
			if (!d) {exit}
			if (d != @name) {
				d.First = Result
			} elseif (result!=@thg) {
				.ErrorAdd( "Must be a proper name (a-z or letters)" )
			} else {
				d.name = result.name
			}
			Result = d
		}
		
		return result
	}


	function MakeYoda (|Message| first, |int| Bits, |Message| Rel, |Message|) {
		// so... just need... an opp, and a thing
		|| last = .ProcessThing( bits&&&~~~kopp, Parser.kExpect )   #require
		Bits &&&= ~~~koppyoda
		Bits |||= koppbra // in case we are in a tmp... just allow it. why not?
						// this is for language, not code!
		|| opp = .Process( bits, Parser.kExpect )	  #require
		rel ~ last
		rel ~ opp
		rel ~ first
		rel.func = @yoda // nice
		return rel 
	}
	

	function MakeRel (|Message| first, |int| Bits, |Message|) {
		|| opp = .Process( Bits )			   // kOpp
		if (!Opp) {
			return first
		}

		|| Rel = parser.new( nil, @Rel, first.Position )
		if (opp==@yopp) {
			return MakeYoda(first, bits, rel)  
		}

		Rel ~ First
		Rel ~ Opp

		// I ¬ home went

		if ( .Eats("=") ) {
			Rel.Func = @ERel
		}
		
		|| Mode = Parser.kAllow
		if (opp == @SOpp) {
			Mode = Parser.kExpect
			Bits |||= koppWord // ||| kopptemporal // right? no point. We can just do: |a| x-y-z
			opp.Func = @opp // sopp is internal only?
		}
		
		|| last = .ProcessThing( Bits, Mode )
		Rel ~ last
		return Rel
	}
	
	
	function ParseLoop (|Message| Output, |string| Ender, |bool|) {
		|| Result = .ParseLoopMode( Output, Output.func.ParseFlags )
		if (Ender) {
			parser.ExpectEndChar(Ender)
		}
		return Result
	}
	
	
	function ConsumeLines (|Message| output = nil, |Message| msg=nil, |bool|) { opt norefcounts
		|| result = false		
		while {
			|| line = .Process( kEndOfLine ||| kSyntacticComment, Parser.kAllow )
			if (line == parser.Avoid) { // cool hack
				result = true
				
			} elseif (!line) {
				output ~ msg
				exit
			} else {
				line ~ msg
				msg = line
			}

			if (msg) {
				debugger output
				output ~ msg
				msg = nil
			}
		}

		return result
	}


/* how to do this:
	a + b
-->
	b + a

	as one line?
	
it's awkward... we need to allow temporals to be at the start of lines
but is that generally useful, or not? Well... it is unambiguous...

what about this:
	
-->
	b + a
	
that seems bad! So we need to reject it...
	
what about this?

	a + b #until #whoops

basically... temporals aren't things... so how to allow them at the start of a line? especially in bracket mode?

	x = (
		a+b
	-->
		b+a
	)

and what to do about this?


	x = (
			a+b
	-->		b+a
	)

its the same? Just... merge it?
	
*/

	function ReRoute (|Message| cnj, |Message| output, |Message|) {
		|| f = output.Last
		if (!f) {
			.ErrorAdd("Can’t use temporals like this.")
			return nil
		}

		|| Result = .ChainTemporalRels( f, cnj )
		// we need to check for the next line, too...

		// a=b,-->,b=a

		if (Result.HasChildCount(2)) and .Allow(kEndOfLine) { // good
			Result ~ .ProcessThing
		}

		return result
	}


	function ParseItem (|Message| ch, |int| TemporalFlags, |Message|) {
		|| Result = parser.new(nil, @Item, .nextstart - 1)
		Result ~ ch
		
		|| ch2 = .Process( TemporalFlags )
		ch2 := .ProcessThing
		ch2 := parser.new(nil, @emb, result.position) // so we can do item.last
		result ~ ch2
		return Result
	}
	
	
	function ParseLoopMode (|Message|Output, |int| Flags, |bool|) {
		|| result = 0
		if (.ConsumeLines(output)) {
			result = 2			// 1 won't work... (,) is a list...
		}

		Flags = Flags &&&~~~ StopBars
		while ( ! .WillEnd ) {
			|| Item = .Process( kTemporal&&&Flags )
			if (!Item) {
				Item = .ProcessThing
				if Item and .Allow(kColon) {
					Item = .ParseItem(Item, Flags)
				}
				if (!item) {
					exit
				}

			} else {
				|| f = item.func
				if (f == @Cnj) or (f == @SCnj) {
					Item = .ReRoute(Item, Output)
					if (!item) {exit}
				}
			}
			
			result++

			if !.ConsumeLines(output, item) {exit}
			result++
		}

		return (result == 1)
	}


	function ProcessThing (|int| Ops=kopp, |bool| Expect=false, |Message|) {
		|| result = .Process( kThing, Expect )
		if (!result or .WillEnd) {
			return result
		}

		Result = .GetFuncAfter( Result )

		if (.WillEnd) { Return result }
		

		|| NotTemp = ops &&& ~~~kOppTemporal
		if (NotTemp and !(result == @Arg)) {
			// problem in here... makerel checks sopp and sets bits to allow temporalrels
			// however we DO need temporalrels! Just for... the FIRST sytnactic opp.
			// not the rest. how do we tell if we are the first? IS there such a thing?
			// maybe? 
//			if (opps &&& koppsyx) {
//				NotTemp |||= kNotFirstSyxOpp
//			}
			result = .MakeRel( result, NotTemp )
		}
		
		if (ops &&& kOppTemporal) {
			|| opp = .Process( kOppTemporal )
			if (opp) {
				Result = .ChainTemporalRels( Result, opp )
			}
		}

		return result
	}


	function Tokens (|[string]| arr, |int|bits, |ParseHandler|func=nil) {
		.Tokens( arr, .Handler( bits, func ) )
	}


	function Tokens (|[string]| arr, |TokenHandler| H) {
		cpp_part TokensHandler
		for (s : arr) {
			.Token( s ) = H
		}
	}


	function Tokenz (|string| s, |int|bits, |ParseHandler| func = nil) {
		if (s contains " ") {
			.Tokens( s.words, bits, func )	
		} else {
			.Token( s ) = .Handler( bits, func )
		}
	}


	function Tokenz (|string| s, |TokenHandler| H) {
		cpp_part TokenzHandler
		.Tokens( s.words, H )	
	}
	

	function WillEnd (|bool|) {
		return .CheckEnded(kEnd)
	}

// more expansive than CSWordStart. Can contain 0-9...
// but the start won't contain that. So won't cause false-negatives...
// or false-positives, really.

	function ErrorLetter (|int| Start) {
		.ErrorAdd( "Expected a letter (aA-zZ, '_', etc).", start )
	}
	
	function WordAfter ( |int| Start, |int| ) {
		opt NoRefCounts
		|| After = .data.OutCharSet( Jeebox.CSWordMiddle, Start )
		if (After == -1 and Start >= .data.length) { 
			//
		} elseif (After != Start) {
			.NextStart = After
			return After
		}
		.ErrorLetter( start )
	}
}




module parser {
	visible false
	cpp_Part Tk
	|string| Data



	flags {
		kAdjectiveOp
		kBracketStart
		kColon

		kEnd			= (kEndOfLine, kEndContainer, kSyntacticComment) 
		kFuncAfterAny   = (kFuncAfterBar, kFuncAfterNormal, kFuncAfterNoSpace) 
		kOpp			= (kOppBra, kOppSyx, kOppTemporal, kOppWord, kOppYoda) 
		kTemporal	   = (kTemporalWord, kTemporalSyx) 
		kThing		  = (kThingSyx, kThingWord, )
		kWords_Line
		kNotFirstSyxOpp

		kOppChain		= kOppWord ||| kOppBra
		kIllegalChar	= 0x8000_0000_
		kAllow		  = false
		kExpect		 = true
		kTmpOpp		 = kOppTemporal ||| kTemporalSyx
	}
	

	|dictionary of string|  ErrorNames = nil
	|int|				   StopBars
	||					  BaseMessagePosition = -1
	|Message--|			 ErrNode
	(ErrorReceiver.new) // Goes into StdErr...
}


//（♯・∀・）⊃
// (ﾉ◕ヮ◕)ﾉ*:･ﾟ✧

	
/*
They want me to explain it. While I have no income but they have great careers. Drain the life out of me... so I can’t make anything more in the future. They want to destroy everything, and do it by forcing me to explain... making me look silly if I don't.
	
	You want a nice quiet peaceful explanation?
	
	The internals work by... RIPPING TO SHIT ALL THE FUCKING EVIL HUMANS, WITH BLAZING DEEP HATE.
	
	In the end... I love myself...
*/

